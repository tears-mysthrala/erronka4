#!/usr/bin/env python3
################################################################################
# Web Vulnerability Scanner
# Zabala Gailetak - Hacking Etikoa
# Script de escaneo de vulnerabilidades web automatizado
################################################################################

import requests
import sys
import json
import argparse
from urllib.parse import urljoin, urlparse
from concurrent.futures import ThreadPoolExecutor, as_completed
import time

class WebVulnerabilityScanner:
    """Scanner de vulnerabilidades OWASP Top 10 para aplicaciones web"""
    
    def __init__(self, target_url, output_file=None):
        self.target_url = target_url
        self.output_file = output_file or f"scan_{int(time.time())}.json"
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'ZabalaGailetak-SecurityScanner/1.0 (Ethical Hacking)'
        })
        self.findings = []
        self.crawled_urls = set()
        
    def log(self, message, level="INFO"):
        """Logging con formato"""
        print(f"[{level}] {message}")
        
    def add_finding(self, vulnerability_type, severity, url, details, remediation):
        """Añadir hallazgo al reporte"""
        finding = {
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
            "type": vulnerability_type,
            "severity": severity,
            "url": url,
            "details": details,
            "remediation": remediation,
            "cvss_score": self.calculate_cvss(severity)
        }
        self.findings.append(finding)
        self.log(f"{vulnerability_type} encontrado en {url} (Severidad: {severity})")
        
    def calculate_cvss(self, severity):
        """Calcular CVSS v3.1 score aproximado"""
        cvss_map = {
            "CRITICAL": 9.8,
            "HIGH": 8.1,
            "MEDIUM": 5.3,
            "LOW": 3.1,
            "INFO": 0.0
        }
        return cvss_map.get(severity.upper(), 5.0)
    
    ############################################################################
    # TESTS DE SEGURIDAD
    ############################################################################
    
    def test_security_headers(self, url):
        """Test A05:2021 - Security Misconfiguration"""
        try:
            response = self.session.get(url, timeout=10)
            headers = response.headers
            
            required_headers = {
                'Strict-Transport-Security': 'HSTS no configurado',
                'X-Content-Type-Options': 'X-Content-Type-Options: nosniff faltante',
                'X-Frame-Options': 'Protección contra Clickjacking faltante',
                'Content-Security-Policy': 'CSP no configurado',
                'X-XSS-Protection': 'X-XSS-Protection faltante',
                'Referrer-Policy': 'Referrer-Policy no configurado'
            }
            
            for header, description in required_headers.items():
                if header not in headers:
                    self.add_finding(
                        "A05: Security Misconfiguration - Missing Header",
                        "MEDIUM",
                        url,
                        f"{description}. Header: {header}",
                        f"Configurar header {header} en el servidor web"
                    )
                    
            # Verificar versión del servidor
            if 'Server' in headers:
                self.add_finding(
                    "A05: Information Disclosure",
                    "LOW",
                    url,
                    f"Versión del servidor expuesta: {headers['Server']}",
                    "Ocultar versión del servidor en las respuestas HTTP"
                )
                
        except Exception as e:
            self.log(f"Error en security_headers: {e}", "ERROR")
    
    def test_sql_injection(self, url):
        """Test A03:2021 - Injection (SQL Injection)"""
        sql_payloads = [
            "' OR '1'='1",
            "' OR 1=1--",
            "' UNION SELECT null,null,null--",
            "1' AND 1=1--",
            "1' AND 1=2--"
        ]
        
        error_patterns = [
            "sql syntax",
            "mysql_fetch",
            "pg_query",
            "sqlite_query",
            "ORA-",
            "Microsoft SQL Server",
            "ODBC SQL Server Driver"
        ]
        
        # Detectar parámetros en URL
        parsed = urlparse(url)
        if parsed.query:
            params = parsed.query.split('&')
            for param in params:
                for payload in sql_payloads:
                    test_url = url.replace(param.split('=')[1], payload) if '=' in param else url
                    try:
                        response = self.session.get(test_url, timeout=10)
                        response_text = response.text.lower()
                        
                        for pattern in error_patterns:
                            if pattern.lower() in response_text:
                                self.add_finding(
                                    "A03: SQL Injection",
                                    "CRITICAL",
                                    test_url,
                                    f"Error SQL detectado con payload: {payload}",
                                    "Usar consultas parametrizadas/prepared statements"
                                )
                                return
                    except:
                        continue
    
    def test_xss(self, url):
        """Test A03:2021 - Cross-Site Scripting (XSS)"""
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "<body onload=alert('XSS')>"
        ]
        
        parsed = urlparse(url)
        if parsed.query:
            for payload in xss_payloads:
                test_url = url.replace(parsed.query.split('=')[1] if '=' in parsed.query else '', payload)
                try:
                    response = self.session.get(test_url, timeout=10)
                    if payload in response.text:
                        self.add_finding(
                            "A03: Cross-Site Scripting (XSS)",
                            "HIGH",
                            test_url,
                            f"XSS reflejado detectado con payload: {payload[:30]}...",
                            "Implementar Content Security Policy y sanitizar entrada de usuario"
                        )
                        return
                except:
                    continue
    
    def test_broken_auth(self, url):
        """Test A07:2021 - Identification and Authentication Failures"""
        login_endpoints = ['/login', '/auth', '/signin', '/api/login']
        
        for endpoint in login_endpoints:
            test_url = urljoin(url, endpoint)
            try:
                # Probar credenciales débiles
                weak_creds = [
                    ('admin', 'admin'),
                    ('admin', 'password'),
                    ('root', 'root'),
                    ('user', 'user')
                ]
                
                for username, password in weak_creds:
                    response = self.session.post(
                        test_url,
                        data={'username': username, 'password': password},
                        timeout=10,
                        allow_redirects=True
                    )
                    
                    # Detectar login exitoso
                    if response.status_code == 200 and any(
                        indicator in response.text.lower() 
                        for indicator in ['dashboard', 'welcome', 'logout', 'profile']
                    ):
                        self.add_finding(
                            "A07: Broken Authentication - Weak Credentials",
                            "CRITICAL",
                            test_url,
                            f"Credenciales débiles funcionan: {username}/{password}",
                            "Implementar política de contraseñas fuertes y MFA"
                        )
                        return
                        
            except Exception as e:
                continue
    
    def test_directory_traversal(self, url):
        """Test A01:2021 - Broken Access Control"""
        traversal_payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\win.ini",
            "....//....//etc/passwd",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd"
        ]
        
        for payload in traversal_payloads:
            test_url = urljoin(url, payload)
            try:
                response = self.session.get(test_url, timeout=10)
                if 'root:x:' in response.text or '[extensions]' in response.text.lower():
                    self.add_finding(
                        "A01: Path Traversal",
                        "HIGH",
                        test_url,
                        "Lectura de archivos arbitrarios detectada",
                        "Validar y sanitizar rutas de archivo, usar chroot jail"
                    )
                    return
            except:
                continue
    
    def test_sensitive_data_exposure(self, url):
        """Test A02:2021 - Cryptographic Failures"""
        sensitive_files = [
            '/.env',
            '/.git/config',
            '/config.php',
            '/database.yml',
            '/wp-config.php',
            '/phpinfo.php',
            '/.htaccess',
            '/robots.txt',
            '/sitemap.xml',
            '/api/swagger.json',
            '/api/docs'
        ]
        
        for file in sensitive_files:
            test_url = urljoin(url, file)
            try:
                response = self.session.get(test_url, timeout=10)
                if response.status_code == 200:
                    # Verificar si contiene información sensible
                    sensitive_patterns = [
                        'password', 'secret', 'api_key', 'database',
                        'DB_HOST', 'DB_PASSWORD', 'APP_KEY'
                    ]
                    
                    if any(pattern in response.text.lower() for pattern in sensitive_patterns):
                        self.add_finding(
                            "A02: Sensitive Data Exposure",
                            "HIGH",
                            test_url,
                            f"Archivo sensible expuesto: {file}",
                            "Restringir acceso a archivos de configuración y eliminar archivos innecesarios"
                        )
            except:
                continue
    
    def test_cors_misconfiguration(self, url):
        """Test A05:2021 - Security Misconfiguration (CORS)"""
        try:
            headers = {
                'Origin': 'https://evil.com'
            }
            response = self.session.get(url, headers=headers, timeout=10)
            
            if 'Access-Control-Allow-Origin' in response.headers:
                allowed_origin = response.headers['Access-Control-Allow-Origin']
                if allowed_origin == '*' or 'evil.com' in allowed_origin:
                    self.add_finding(
                        "A05: CORS Misconfiguration",
                        "MEDIUM",
                        url,
                        f"CORS permite origen no seguro: {allowed_origin}",
                        "Configurar CORS con whitelist de dominios permitidos"
                    )
        except:
            pass
    
    def crawl(self, url, depth=2):
        """Crawling básico de la aplicación"""
        if depth == 0 or url in self.crawled_urls:
            return
            
        self.crawled_urls.add(url)
        
        try:
            response = self.session.get(url, timeout=10)
            
            # Extraer links
            import re
            links = re.findall(r'href=["\'](.*?)["\']', response.text)
            
            for link in links:
                absolute_url = urljoin(url, link)
                if absolute_url.startswith(self.target_url):
                    self.crawl(absolute_url, depth - 1)
                    
        except:
            pass
    
    def run_scan(self):
        """Ejecutar escaneo completo"""
        self.log(f"Iniciando escaneo de {self.target_url}")
        
        # Crawling
        self.log("Fase 1: Crawling de aplicación...")
        self.crawl(self.target_url)
        self.log(f"URLs descubiertas: {len(self.crawled_urls)}")
        
        # Tests de seguridad
        self.log("Fase 2: Tests de seguridad...")
        
        urls_to_scan = [self.target_url] + list(self.crawled_urls)
        
        with ThreadPoolExecutor(max_workers=5) as executor:
            future_to_url = {}
            
            for url in urls_to_scan[:20]:  # Limitar a 20 URLs
                future_to_url[executor.submit(self.test_security_headers, url)] = url
                future_to_url[executor.submit(self.test_sql_injection, url)] = url
                future_to_url[executor.submit(self.test_xss, url)] = url
                future_to_url[executor.submit(self.test_directory_traversal, url)] = url
                future_to_url[executor.submit(self.test_cors_misconfiguration, url)] = url
            
            for future in as_completed(future_to_url):
                try:
                    future.result()
                except Exception as e:
                    pass
        
        # Tests adicionales
        self.test_broken_auth(self.target_url)
        self.test_sensitive_data_exposure(self.target_url)
        
        # Generar reporte
        self.generate_report()
    
    def generate_report(self):
        """Generar reporte JSON"""
        report = {
            "scan_info": {
                "target": self.target_url,
                "scan_date": time.strftime("%Y-%m-%d %H:%M:%S"),
                "scanner_version": "1.0",
                "total_urls_scanned": len(self.crawled_urls) + 1
            },
            "summary": {
                "total_findings": len(self.findings),
                "critical": len([f for f in self.findings if f['severity'] == 'CRITICAL']),
                "high": len([f for f in self.findings if f['severity'] == 'HIGH']),
                "medium": len([f for f in self.findings if f['severity'] == 'MEDIUM']),
                "low": len([f for f in self.findings if f['severity'] == 'LOW']),
                "info": len([f for f in self.findings if f['severity'] == 'INFO'])
            },
            "findings": self.findings
        }
        
        with open(self.output_file, 'w') as f:
            json.dump(report, f, indent=2)
            
        self.log(f"Reporte generado: {self.output_file}")
        self.log(f"Hallazgos: {len(self.findings)} ({report['summary']['critical']} Críticos, "
                 f"{report['summary']['high']} Altos, {report['summary']['medium']} Medios)")

################################################################################
# MAIN
################################################################################

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Web Vulnerability Scanner - Zabala Gailetak')
    parser.add_argument('url', help='URL objetivo a escanear')
    parser.add_argument('-o', '--output', help='Archivo de salida JSON')
    parser.add_argument('--threads', type=int, default=5, help='Número de threads')
    
    args = parser.parse_args()
    
    # Validar URL
    if not args.url.startswith(('http://', 'https://')):
        print("Error: La URL debe comenzar con http:// o https://")
        sys.exit(1)
    
    # Ejecutar scanner
    scanner = WebVulnerabilityScanner(args.url, args.output)
    scanner.run_scan()
